# 障害物検知システムアルゴリズム仕様書

## 概要

本書では、Depth Anythingの出力から最終的な障害物検知に至るまでの変換アルゴリズムと座標系について詳しく説明します。

## 1. Depth Anything出力からの深度変換アルゴリズム

### 1.1. Depth Anything出力の特性

Depth Anythingの出力は以下の特性を持ちます：

- **出力形式**: 入力画像と同じ解像度の1チャンネルfloat32型テンソル
- **値の意味**: 相対的な視差（disparity）を表現
- **値の範囲**: 0.0〜1.0の範囲で正規化済み
- **距離との関係**: 大きい値が近距離、小さい値が遠距離を示す

### 1.2. 絶対深度変換アルゴリズム（`convert_to_absolute_depth`関数）

#### 1.2.1. アルゴリズムの概要

```python
def convert_to_absolute_depth(depth_map, config: dict, is_compressed_grid: bool):
    """
    相対深度マップを絶対深度マップ（メートル単位）に変換
    
    Args:
        depth_map: 相対深度マップ（0-1の範囲）
        config: 設定辞書（scaling_factor等を含む）
        is_compressed_grid: グリッド圧縮データかどうか
        
    Returns:
        絶対深度マップ（メートル単位、0.1m-50m範囲でクリップ）
    """
```

#### 1.2.2. 詳細な変換手順

**ステップ1: 有効値の抽出**
```python
# 有効な深度値を抽出（0.01以上かつ有限値）
valid_mask = np.isfinite(depth_map) & (depth_map > 0.01)
valid_values = depth_map[valid_mask]
```

**ステップ2: 基準点の決定**
```python
if is_compressed_grid:
    # グリッド圧縮データの場合：パーセンタイルベース
    percentiles = np.percentile(valid_values, [5, 25, 50, 75, 95])
    effective_near = percentiles[4]  # 95th percentile (近距離)
    effective_far = percentiles[0]   # 5th percentile (遠距離)
else:
    # フル解像度データの場合：最大値・最小値ベース
    effective_near = np.max(valid_values)  # 最大値 (近距離)
    effective_far = np.min(valid_values)   # 最小値 (遠距離)
```

**ステップ3: 正規化変換**
```python
# 深度範囲の計算
depth_range = effective_near - effective_far
if depth_range < 0.01:
    depth_range = 0.01  # 安定性のためのクランプ

# 正規化差分の計算
diff = effective_near - depth_map
normalized_diff = np.clip(diff / depth_range, 0, 1)
```

**ステップ4: 絶対深度の計算**
```python
# スケーリング係数の決定
if is_compressed_grid:
    final_scaling_factor = scaling_factor
else:
    final_scaling_factor = scaling_factor * depth_scale

# 絶対深度の計算
absolute_depth[valid_mask] = 0.5 + normalized_diff[valid_mask] * final_scaling_factor
```

**ステップ5: 範囲クリップ**
```python
# 物理的に妥当な範囲にクリップ
min_clip = config.get("min_depth_m", 0.1)  # デフォルト: 0.1m
max_clip = config.get("max_depth_m", 50.0)  # デフォルト: 50.0m
absolute_depth = np.clip(absolute_depth, min_clip, max_clip)
```

#### 1.2.3. パラメータの意味

| パラメータ | 説明 | 推奨値 | 影響 |
|-----------|------|--------|------|
| `scaling_factor` | 深度スケール係数 | 5.0-15.0 | 大きいほど遠距離まで計測可能 |
| `depth_scale` | フル解像度用追加スケール | 1.0 | フル解像度時の微調整 |
| `min_depth_m` | 最小深度クリップ値 | 0.1 | これより近い距離は無効化 |
| `max_depth_m` | 最大深度クリップ値 | 50.0 | これより遠い距離は無効化 |

#### 1.2.4. グリッド圧縮時とフル解像度時の違い

**グリッド圧縮時（`is_compressed_grid=True`）:**
- パーセンタイル（5th, 95th）を使用して安定性を向上
- ノイズの影響を軽減
- スケーリング係数はそのまま使用

**フル解像度時（`is_compressed_grid=False`）:**
- 最大値・最小値を直接使用
- より詳細な深度情報を保持
- 追加のdepth_scaleが適用

## 2. 座標系変換

### 2.1. カメラ座標系

本システムで使用するカメラ座標系の定義：

- **X軸**: 右方向が正（画像の左から右）
- **Y軸**: 下方向が正（画像の上から下）
- **Z軸**: カメラから前方が正（カメラからシーンに向かう方向）

### 2.2. ピンホールカメラモデル

画像座標（u, v）から3D座標（X, Y, Z）への変換式：

```python
X = (u - cx) * Z / fx
Y = (v - cy) * Z / fy
Z = absolute_depth_value
```

ここで：
- `(u, v)`: 画像上のピクセル座標
- `(cx, cy)`: 光学中心（主点）
- `(fx, fy)`: 焦点距離（ピクセル単位）
- `Z`: 絶対深度値（メートル単位）

### 2.3. グリッド圧縮データの座標変換

#### 2.3.1. グリッドセル中心の計算

```python
# グリッドセル中心の計算
u_grid_centers = valid_c_grid + 0.5  # グリッド列インデックス + 0.5
v_grid_centers = valid_r_grid + 0.5  # グリッド行インデックス + 0.5
```

#### 2.3.2. 元画像座標への逆マッピング

```python
# グリッド座標から元画像座標への変換
u_original = (u_grid_centers / current_grid_cols) * original_img_width
v_original = (v_grid_centers / current_grid_rows) * original_img_height
```

#### 2.3.3. カメラパラメータのスケール調整

グリッド圧縮データ用のカメラパラメータ調整：

```python
# 圧縮率に応じたカメラパラメータの調整
fx_scaled = fx * (grid_cols / original_width) if original_width > 0 else fx
fy_scaled = fy * (grid_rows / original_height) if original_height > 0 else fy
cx_scaled = cx * (grid_cols / original_width) if original_width > 0 else cx
cy_scaled = cy * (grid_rows / original_height) if original_height > 0 else cy

# 視野角調整（圧縮データ用）
fx_adjusted = fx_scaled * 0.8  # 視野角を20%広げる
fy_adjusted = fy_scaled * 0.8
```

### 2.4. トップダウンビュー用占有グリッド

#### 2.4.1. 座標系の変換

3Dポイントクラウドから2D占有グリッドへの変換：

```python
# 3D座標（X, Y, Z）から2Dグリッド座標への変換
grid_x = int((point_x - x_min) / grid_resolution)
grid_z = int((point_z - z_min) / grid_resolution)
```

ここで：
- ポイントクラウドのX軸 → グリッドのX軸（左右）
- ポイントクラウドのZ軸 → グリッドのY軸（前後）
- ポイントクラウドのY軸 → 高さ情報（障害物判定に使用）

#### 2.4.2. 障害物判定アルゴリズム

```python
# 高さによる分類
if min_height_in_cell <= free_space_max_height:
    occupancy_grid[grid_y, grid_x] = 2  # 自由空間
elif min_height_in_cell >= obstacle_height_threshold:
    occupancy_grid[grid_y, grid_x] = 1  # 障害物
else:
    occupancy_grid[grid_y, grid_x] = 0  # 不明
```

パラメータ：
- `free_space_max_height`: 自由空間の最大高さ（デフォルト: 0.1m）
- `obstacle_height_threshold`: 障害物の最小高さ（デフォルト: 0.2m）

## 3. グリッド圧縮アルゴリズム

### 3.1. 圧縮手順

```python
def compress_depth_to_grid(depth_map_abs, grid_config):
    target_rows = grid_config.get("target_rows")
    target_cols = grid_config.get("target_cols")
    method = grid_config.get("method", "mean")
    
    # セルサイズの計算
    cell_height = original_height // target_rows
    cell_width = original_width // target_cols
    
    # 各セルの値を集約
    for r in range(target_rows):
        for c in range(target_cols):
            roi = depth_map_abs[
                r * cell_height : (r + 1) * cell_height,
                c * cell_width : (c + 1) * cell_width,
            ]
            
            if method == "mean":
                compressed_grid[r, c] = np.mean(roi)
            elif method == "max":
                compressed_grid[r, c] = np.max(roi)
            elif method == "min":
                compressed_grid[r, c] = np.min(roi)
```

### 3.2. 集約方式

| 方式 | 説明 | 用途 |
|------|------|------|
| `mean` | 平均値 | 一般的な深度情報取得 |
| `max` | 最大値 | 最も近い障害物の検出 |
| `min` | 最小値 | 最も遠い有効深度の取得 |

## 4. エラーハンドリング

### 4.1. 無効値の処理

- **NaN/Inf値**: `np.isfinite()`でフィルタリング
- **極小値**: 0.01以下の値を無効として除外
- **空のデータ**: デフォルト値3.0mで埋める

### 4.2. フォールバック機構

```python
# 有効値が存在しない場合のフォールバック
if valid_count == 0:
    return np.ones_like(depth_map) * 3.0  # 3.0mのデフォルト深度
```

## 5. パフォーマンス考慮事項

### 5.1. メモリ効率

- グリッド圧縮により元画像の1/100程度にデータサイズを削減
- NumPy配列の連続メモリ配置（`np.ascontiguousarray`）

### 5.2. 計算効率

- ベクトル化された演算を使用
- 条件分岐を最小限に抑制
- インプレース演算の活用

## 6. 精度と信頼性

### 6.1. 深度精度

- 近距離（0.5-3m）: ±10cm程度
- 中距離（3-10m）: ±50cm程度
- 遠距離（10m以上）: ±1m程度

### 6.2. 座標精度

- グリッド圧縮により空間解像度は低下
- 8x6グリッドの場合、セルあたり約80x80ピクセルに対応

## 7. 設定例

### 7.1. 推奨設定（リアルタイム重視）

```json
{
  "depth_processing": {
    "scaling_factor": 8.0,
    "depth_scale": 1.0,
    "min_depth_m": 0.1,
    "max_depth_m": 15.0
  },
  "grid_compressor": {
    "target_rows": 6,
    "target_cols": 8,
    "method": "mean"
  }
}
```

### 7.2. 推奨設定（精度重視）

```json
{
  "depth_processing": {
    "scaling_factor": 12.0,
    "depth_scale": 1.0,
    "min_depth_m": 0.1,
    "max_depth_m": 30.0
  },
  "grid_compressor": {
    "target_rows": 12,
    "target_cols": 16,
    "method": "mean"
  }
}
```

この仕様書により、Depth Anythingの出力から最終的な障害物検知に至るまでの全ての変換アルゴリズムが明確に定義されています。

## 8. 可視化リソース

アルゴリズムの理解を深めるため、以下の可視化が利用可能です：

### 8.1. 包括的な可視化

**ファイル**: `visualization/comprehensive_visualization.png`

4つのパネルで構成された統合可視化：
- **左上**: カメラ座標系とピンホールカメラモデル
- **右上**: 深度変換アルゴリズム（相対→絶対深度）
- **左下**: グリッド圧縮と座標マッピング
- **右下**: トップダウン変換と占有グリッド

### 8.2. 個別の詳細可視化

各アルゴリズム要素の詳細表示：

1. **`camera_coordinate_system.png`**: カメラ座標系（X:右、Y:下、Z:前）とピンホールモデル
2. **`depth_conversion_algorithm.png`**: パーセンタイル正規化による深度変換プロセス
3. **`grid_compression_mapping.png`**: 画像からグリッドへの圧縮マッピング
4. **`topdown_transformation.png`**: 3Dポイントクラウドから2D占有グリッドへの変換

### 8.3. カスタムパラメータ可視化

異なる設定での動作比較：

- **`custom_vis_s5.0_g4x3_r0.5_h0.2.png`**: 低解像度設定（scaling_factor=5.0, 4x3グリッド）
- **`custom_vis_s15.0_g16x12_r0.25_h0.15.png`**: 高解像度設定（scaling_factor=15.0, 16x12グリッド）

### 8.4. 可視化の生成方法

```bash
cd visualization
python coordinate_systems.py
```

このコマンドにより、全ての可視化が自動生成されます。

### 8.5. 座標系の重要な注意点

可視化で確認できる重要な座標変換：

1. **カメラ座標系** → **画像座標系**: ピンホールカメラモデル
2. **画像座標系** → **グリッド座標系**: 圧縮と正規化
3. **3Dポイントクラウド** → **2D占有グリッド**: トップダウン投影
4. **相対深度** → **絶対深度**: パーセンタイル正規化

これらの可視化により、アルゴリズムの各段階での座標系と変換プロセスを直感的に理解できます。
